import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * in JSON form based on:
 *   - a list of interest descriptions
 *   - a list of already-completed UofT course codes.
 */
public final class LLMs {

    // Gemini Developer API endpoint (v1beta generateContent)
    private static final String GEMINI_ENDPOINT =
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";

    private final HttpClient httpClient;
    private final String apiKey;

    /**
     * Creates an instance using the GEMINI_API_KEY environment variable.
     */
    public LLMs() {
        this(System.getenv("AIzaSyBE6rg-j3hyXHvz9uYX01BbbjFDDm-vgKk"));
    }

    /**
     * Creates an instance with an explicit API key.
     */
    public LLMs(String apiKey) {
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(10))
                .build();
        this.apiKey = Objects.requireNonNull(apiKey, "API key must not be null");
        if (this.apiKey.isBlank()) {
            throw new IllegalArgumentException("API key must not be blank");
        }
    }

    /**
     * Calls Gemini and returns the model's JSON output as a String.
     * <p>
     * The JSON is generated by Gemini and should look like:
     *
     * [
     *   { "courseCode": "CSC207H1", "description": "..." },
     *   { "courseCode": "MAT135H1", "description": "..." }
     * ]
     *
     * @param interests        list of interest descriptions (e.g. "machine learning", "philosophy of mind")
     * @param completedCourses list of completed UofT course codes (e.g. "CSC108H1", "MAT135H1")
     * @return JSON string produced by the model (array of objects with courseCode + description)
     */
    public String generateCourseRecommendations(List<String> interests,
                                                List<String> completedCourses)
            throws IOException, InterruptedException {

        Objects.requireNonNull(interests, "interests must not be null");
        Objects.requireNonNull(completedCourses, "completedCourses must not be null");

        if (interests.isEmpty()) {
            throw new IllegalArgumentException("At least one interest is required");
        }

        String prompt = buildPrompt(interests, completedCourses);
        String requestBodyJson = buildRequestBody(prompt);

        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(GEMINI_ENDPOINT + "?key=" + apiKey))
                .header("Content-Type", "application/json")
                .timeout(Duration.ofSeconds(30))
                .POST(HttpRequest.BodyPublishers.ofString(requestBodyJson))
                .build();

        HttpResponse<String> response =
                httpClient.send(request, HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() != 200) {
            throw new IOException("Gemini API call failed with status "
                    + response.statusCode() + ": " + response.body());
        }

        // The response body is a big JSON object from Gemini.
        // Inside it, the model's JSON is in the first candidate's content.parts[0].text.
        return extractModelJson(response.body());
    }

    /**
     * Builds the natural-language prompt that Gemini will see.
     */
    private String buildPrompt(List<String> interests, List<String> completedCourses) {
        String interestsText = interests.stream()
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.joining(", "));

        String completedText = completedCourses.isEmpty()
                ? "none"
                : completedCourses.stream()
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.joining(", "));

        return """
                You are a course recommendation assistant for the University of Toronto.

                The student is interested in the following topics:
                %s

                The student has already completed the following U of T courses:
                %s

                Task:
                - Recommend ALL relevant U of T course codes that match the student's interests.
                - Only include valid U of T course codes (e.g., CSC207H1, MAT135H1, POL101Y1).
                - Do NOT include any courses the student has already completed.
                - Focus on courses that are realistically available to an undergraduate student.

                Output format:
                - Return ONLY a JSON array (no extra text, no explanations).
                - Each element in the array must be an object with these exact fields:
                    - "courseCode": string
                    - "description": string

                Example of the expected format (example values only):
                [
                  { "courseCode": "CSC207H1", "description": "Introduction to software design and architecture." },
                  { "courseCode": "MAT137Y1", "description": "Rigorous calculus with an emphasis on proof." }
                ]
                """.formatted(interestsText, completedText);
    }

    /**
     * Builds the JSON request body for the Gemini generateContent API.
     * We construct the JSON string manually to avoid third-party libraries.
     */
    private String buildRequestBody(String prompt) {
        String escapedPrompt = escapeJson(prompt);

        // Minimal JSON for:
        // {
        //   "contents": [ { "parts": [ { "text": "<prompt>" } ] } ],
        //   "generationConfig": { "response_mime_type": "application/json" }
        // }
        return "{"
                + "\"contents\":[{\"parts\":[{\"text\":\"" + escapedPrompt + "\"}]}],"
                + "\"generationConfig\":{\"response_mime_type\":\"application/json\"}"
                + "}";
    }

    /**
     * Escapes a Java string so it can safely appear as a JSON string value.
     */
    private static String escapeJson(String s) {
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            switch (c) {
                case '\\' -> sb.append("\\\\");
                case '"'  -> sb.append("\\\"");
                case '\n' -> sb.append("\\n");
                case '\r' -> sb.append("\\r");
                case '\t' -> sb.append("\\t");
                default   -> sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * Extracts the model's JSON (the array of courses) from the Gemini response.
     *
     * We expect the JSON array to appear as a string in:
     *   candidates[0].content.parts[0].text
     *
     * We do a simple parse using String operations (no external JSON library).
     */
    private String extractModelJson(String responseBody) {
        // Very basic extraction:
        // 1. Find the first occurrence of `"text":`
        // 2. Find the following double quote
        // 3. Read until the closing unescaped double quote

        String marker = "\"text\":";
        int markerIndex = responseBody.indexOf(marker);
        if (markerIndex < 0) {
            // Fallback: return whole body if format is unexpected
            return responseBody.trim();
        }

        int firstQuote = responseBody.indexOf('"', markerIndex + marker.length());
        if (firstQuote < 0) {
            return responseBody.trim();
        }

        StringBuilder result = new StringBuilder();
        boolean escaped = false;

        for (int i = firstQuote + 1; i < responseBody.length(); i++) {
            char c = responseBody.charAt(i);

            if (escaped) {
                // Handle common escape sequences
                switch (c) {
                    case 'n' -> result.append('\n');
                    case 'r' -> result.append('\r');
                    case 't' -> result.append('\t');
                    case '"' -> result.append('"');
                    case '\\' -> result.append('\\');
                    default -> result.append(c);
                }
                escaped = false;
            } else if (c == '\\') {
                escaped = true;
            } else if (c == '"') {
                // End of JSON string
                break;
            } else {
                result.append(c);
            }
        }

        // This should now be the JSON array string we asked Gemini to produce.
        return result.toString().trim();
    }

    /**
     * Simple CLI demo / manual test.
     * Make sure you have GEMINI_API_KEY set in your environment.
     */
    public static void main(String[] args) throws Exception {
        LLMs client = new LLMs();

        List<String> interests = List.of(
                "artificial intelligence",
                "software engineering",
                "human-computer interaction"
        );

        List<String> completed = List.of(
                "CSC108H1",
                "CSC148H1"
        );

        String json = client.generateCourseRecommendations(interests, completed);
        System.out.println(json);
    }
}
